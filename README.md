# Блочная(корзинная) сортировка
**Определение:** Блочная сортировка (bucket sort) — это алгоритм, который распределяет
элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
объединяются обратно в один массив.
## Принцип работы
**Определение максимального и минимального значений:**
`max_value = max(arr)`
`min_value = min(arr)`
Эти операции нужны для расчета ширины диапазонов каждого бака.

**Создание баков:**
`buckets = [[] for _ in range(bucket_count)]`

**Распределение элементов по бакам:**
`index = int((value - min_value) // bucket_size)`
Каждое значение размещается в соответствующий бак, основываясь на своем положении в общем диапазоне.

**Сортировка каждого бака:**
`final_result.extend(insertion_sort(bucket))`
Используется простая сортировка вставками для каждого отдельного бака.

**Сборка результатов:**
Все отсортированные баки сливаются в единый отсортированный массив.

## Анализ временной сложности в худшем случае**
**Распределение элементов по бакам:**
O(n), где n — количество элементов в массиве.
**Сортировка каждого бака:**
Среднее время работы сортировки вставками в одном бакете — 
O(m*logm), где m — среднее количество элементов в баке. Обычно предполагается, что количество элементов в каждом баке близко к 
m≈k, где k — количество баков.
Но в худшем случае (все элементы попадают в один бак), сложность становится 
O(n^2), так как фактически приходится применять внутреннюю сортировку ко всему массиву целиком.

Итак, в худшем случае, временная сложность блочной сортировки достигает 
O(n^2), что объясняется возможностью концентрации всех элементов в одном баке, приводящей к полной сортировке вставками большого объема данных.
# Блинная сортировка
**Определение:** Блинная сортировка (pancake sort) — это метод, основанный на операции
переворота (reversal) части массива. В отличие от большинства алгоритмов, которые
обменивают соседние элементы или выбирают опорные точки, здесь единственная
разрешённая операция — переворот префикса массива до выбранного индекса.
## Принцип работы
**Функция flip():**
`def flip(arr, k):`
Эта функция переворачивает первые k элементов массива. Она меняет местами пары элементов, двигаясь навстречу друг другу от краев к центру.

**Функция pancake_sort():**
`def pancake_sort(arr):`
**Главная логика алгоритма:**
Сначала находим индекс наибольшего элемента в текущей несортированной части массива.
Если наибольший элемент не находится в конце текущей части, делаем два переворота:
Первый переворот поднимает наибольший элемент наверх.
Второй переворот опускает наибольший элемент вниз, на его конечное место.
Затем уменьшаем размер несортированной части и повторяем процедуру.

**Основной цикл:**
`while current_size > 1`
Цикл продолжается, пока остается хотя бы два несортированных элемента.

**Операция нахождения максимума:**
`max_index = arr.index(max(arr[:current_size]))`
Находит индекс наибольшего элемента в текущей несортированной части массива.

**Два последовательных переворота:**
`flip(arr, max_index + 1)flip(arr, current_size)`
Два переворота обеспечивают перемещение наибольшего элемента на нужное место.

## Временная сложность в худшем случае:
Временная сложность блинной сортировки в худшем случае — O(n^2).

**Обоснование:**

Нахождение максимума:Каждая итерация включает операцию поиска наибольшего элемента в текущей части массива, что требует O(n) операций.
Количество итераций:Всего выполняется n−1 итераций (каждый раз уменьшается размер несортированной части на единицу).
Перевороты:Каждый переворот требует O(n) операций (перестановка элементов).
Таким образом, суммируя временную сложность для каждого алгоритма, получаем O(n^2)